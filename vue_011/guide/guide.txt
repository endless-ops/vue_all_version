1. 安装
    1.1 独立
        引入 js 文件
            开发版：https://raw.githubusercontent.com/yyx990803/vue/0.11.10/dist/vue.js
            生产版：https://raw.github.com/yyx990803/vue/0.11.10/dist/vue.min.js

    1.2 使用 npm
        $ npm install vue

        # 对于边缘版本：
        $ npm install yyx990803/vue #dev

    1.3 Bower
        # only stable version is available through Bower
        $ bower install vue

    1.4 Duo
        var Vue = require('yyx990803/vue')
        // for edge version:
        var Vue = require('yyx990803/vue@dev')

    1.5 Component
        $ component install yyx990803/vue
        # for edge version:
        $ component install yyx990803/vue@dev


    AMD 模块加载器
        通过 Bower 安装的独立下载或版本使用 UMD 进行包装，因此它们可以直接用作 AMD 模块。

2. 介绍
    Vue.js 是一个用于构建交互式 Web 界面的库。

    从技术上讲，Vue.js 专注于 MVVM 模式的ViewModel层。它通过两种方式数据绑定连接视图和模型。实际的 DOM 操作和输出格式被抽象为Directives和Filters。

    从哲学上讲，目标是通过尽可能简单的 API 提供反应式数据绑定和可组合视图组件的好处。它不是一个成熟的框架——它被设计成一个简单灵活的视图层。您可以单独使用它进行快速原型设计，
    也可以与其他库混合搭配以实现自定义前端堆栈。它也非常适合 Firebase 等无后端服务。

    Vue.js 的 API 深受AngularJS、KnockoutJS、Ractive.js和Rivets.js的影响。尽管有相似之处，但我相信 Vue.js 通过找到简单性和功能性之间的最佳平衡点，为这些现有库提供了一个有价值的替代方案。

    2.1 概念概述
        2.1.1 ViewModel
            同步模型和视图的对象。在 Vue.js 中，每个 Vue 实例都是一个 ViewModel。它们使用Vue构造函数或其子类进行实例化：

            var vm = new Vue({ /* 选项 */ })

        2.1.2 View
            vm.$el // The View

            Vue.js 使用基于 DOM 的模板。每个 Vue 实例都与一个对应的 DOM 元素相关联。创建 Vue 实例时，它会递归遍历其根元素的所有子节点，同时设置必要的数据绑定。视图编译后，它会响应数据更改。

            使用 Vue.js 时，您很少需要自己接触 DOM，除非在自定义指令中（稍后解释）。数据变化时会自动触发视图更新。这些视图更新非常精细，精确到一个 textNode。它们还被批处理并异步执行以提高性能。

        2.1.3 Model
            vm.$data // 模型

            在 Vue.js 中，模型只是简单的 JavaScript 对象或数据对象。您可以操作它们的属性，并且正在观察它们的 Vue 实例将收到更改通知。Vue.js 通过将数据对象的属性转换为 ES5 getter/setter 来实现透明的反应性。
            不需要脏检查，也不需要显式地向 Vue 发出信号来更新视图。每当数据发生变化时，视图都会在下一帧更新。

            Vue 实例代理了它们观察到的数据对象的所有属性。因此，一旦{ a: 1 }观察到一个对象，两者vm.$data.a和vm.a都将返回相同的值，并且设置vm.a = 2将修改vm.$data。

            数据对象在原地发生变异，因此通过引用修改它与修改vm.$data. 这使得多个 Vue 实例可以观察同一条数据。在较大的应用程序中，还建议将 Vue 实例视为纯视图，并将数据操作逻辑外部化到更离散的存储层中。

            这里需要注意的是，一旦开始观察，Vue.js 将无法检测到新添加或删除的属性。为了解决这个问题，观察到的对象会增加$add,$set和$delete方法。

        2.1.4 Directives 指令
            带前缀的 HTML 属性，告诉 Vue.js 对 DOM 元素做一些事情。

                < div  v-text = "消息" > </ div >

            这里 div 元素有一个v-text值为 的指令message。这告诉 Vue.js 保持 div 的 textContent 与 Vue 实例的message属性同步。

            指令可以封装任意 DOM 操作。例如v-attr操作元素的属性、v-repeat基于数组克隆元素、v-on附加事件侦听器……我们稍后会介绍它们。

        2.1.5 Mustache Bindings 小胡子绑定
            您还可以在文本和属性中使用 mustache 样式的绑定。它们被翻译成引擎盖下的指令v-text。v-attr例如：
                < div  id = "person-{{id}}" >你好 {{name}}！</ div >
            尽管它很方便，但您需要注意以下几点：
                元素上的src属性在<image>设置值时发出 HTTP 请求，因此在第一次解析模板时会导致 404。在这种情况下v-attr是首选。
                Internet Explorer 会style在解析 HTML 时移除无效的内联属性，因此v-style如果您想支持 IE，请务必在绑定内联 CSS 时使用。

            您可以对未转义的 HTML 使用三重胡须，这在v-html内部转换为：

                {{{ safeHTMLString }}}

            但是，这可能会为潜在的 XSS 攻击打开窗口，因此建议您仅在您绝对确定数据源的安全性时使用三重胡须，或者通过自定义过滤器过滤不受信任的 HTML。

            最后，您可以添加*到您的 mustache 绑定以指示一次性插值，它不会对数据更改做出反应：

                {{* onlyOnce }}

        2.1.6 Filters 过滤器
            过滤器是用于在更新视图之前处理原始值的函数。它们由指令或绑定中的“管道”表示：

                < div > {{ message | capitalize }} </ div >
            现在在更新 div 的 textContent 之前，该message值将首先通过capitalize函数传递。有关更多详细信息，请参阅深度过滤器。

        2.1.7 Components
            在 Vue.js 中，每个组件都只是一个 Vue 实例。组件形成一个嵌套的树状层次结构，代表您的应用程序界面。
            Vue.extend它们可以通过从Vue.component(id, constructor). 注册后，它们可以声明式地嵌套在其他 Vue 实例的模板中，
            使用v-component指令：
                < div  v-component = "my-component" > <!-- my-component 处理的内部 --> </ div >
            这种简单的机制以类似于Web Components的方式实现了 Vue 实例的声明式重用和组合，而无需最新的浏览器或繁重的 polyfill。
            通过将应用程序分解成更小的组件，结果是一个高度解耦和可维护的代码库。有关详细信息，请参阅组件系统。


        2.1.8 一个简单的例子
                <div id="demo">
                    <h1> {{title | 大写}} </h1>
                    <ul>
                        <li v-repeat="todos" v-on = "click: done = !done" class = "{{done ? 'done' : ''}}"> {{内容}} </li>
                    </ul>
                </div>

                var demo = new Vue({
                  el: '#demo' ,
                  data: {
                    title: 'todos' ,
                    todos: [
                      {
                        done: true ,
                        content: 'Learn JavaScript'
                       },
                      {
                        done: false ,
                        content: '学习 Vue. js'
                       }
                    ]
                  }
                })

        2.1.9

 3. 指令
    3.1 概要
        如果你以前没有使用过 AngularJS，你可能不知道指令是什么。本质上，指令是标记中的一些特殊标记，它告诉库对 DOM 元素执行某些操作。
        在 Vue.js 中，指令的概念比 Angular 中的要简单得多。Vue.js 指令只能以采用以下格式的前缀 HTML 属性的形式出现：
            <element prefix-directiveId = "[argument:] 表达式 [| filters...]">

            </element>


    3.2 一个简单的例子
        <div  v-text = "消息" > </div>
        这里的前缀是v默认值。指令 ID 是text，表达式是message。该指令指示 Vue.js在 Vue 实例上textContent的属性更改时更新 div。message

    3.3 Inline Expressions 内联表达式
        <div  v-text = "'hello'+user.firstName+''+user.lastName" > </div>
        在这里，我们使用计算表达式而不是单个属性键。Vue.js 会自动跟踪表达式所依赖的属性，并在依赖项更改时刷新指令。由于异步批量更新，即使多个依赖项发生更改，表达式也只会在每个事件循环中更新一次。
        您应该明智地使用表达式并避免在模板中放置过多的逻辑，尤其是具有副作用的语句（事件侦听器表达式除外）。为了阻止模板内过度使用逻辑，Vue.js 内联表达式仅限于一个语句。对于需要更复杂操作的绑定，请改用计算属性。
        出于安全原因，在内联表达式中，您只能访问当前上下文 Vue 实例及其父级中存在的属性和方法。

    3.4 Argument 争论
        <div v-on = "点击:clickHandler" > </div>
        一些指令在键路径或表达式之前需要一个参数。在这个例子中，click参数表明我们希望v-on指令监听点击事件，然后调用clickHandlerViewModel 实例的方法。

    3.5 Filters 过滤器
        过滤器可以附加到指令键路径或表达式中，以在更新 DOM 之前进一步处理值。过滤器由一个管道 ( |) 表示，就像在 shell 脚本中一样。有关更多详细信息，请参阅深度过滤器。

    3.6 Multiple Clauses 多个子句
        您可以在单个属性中创建同一指令的多个绑定，以逗号分隔。在引擎盖下，它们被绑定为多个指令实例。
            <div  v-on = "
              点击:onClick,
              keyup:onKeyup,
              keydown:onKeydown
            " >
            </div>
    3.7 Literal Directives  文字指令
        一些指令不创建数据绑定——它们只是将属性值作为文字字符串。例如v-component指令：
            < div  v-component = "我的组件" > </ div >
        这里"my-component"不是数据属性——它是 Vue.js 用来查找相应组件构造函数的字符串 ID。

        您还可以在文字指令中使用 mustache 表达式以使其具有反应性。例如，以下代码允许您动态解析要使用的组件类型：
            < div  v-component = "{{ isOwner ? 'owner-panel' : 'guest-panel' }}" > </ div >
        当胡须内的表达式发生变化时，渲染的组件也会相应地发生变化！

        但是，请注意，并非所有文字指令都可以具有这种反应性行为。支持这种用法的内置指令包括v-component,v-partial和v-transition.
        其他文字指令中的 Mustache 表达式，例如v-ref和v-el，只计算一次。编译指令后，它将不再对值更改做出反应。

    3.8 Empty Directives 空指令
        一些指令甚至不期望属性值——它们只是对元素做一次且仅一次。例如v-pre指令：
            < div  v-pre > <!-- 这里的标记不会被编译--> </ div >
        可以在API 参考中找到完整的空指令列表。

4. 过滤器
    4.1 概要
        Vue.js 过滤器本质上是一个函数，它接受一个值，对其进行处理，然后返回处理后的值。在标记中，它由一个竖线 ( |) 表示，并且可以后跟一个或多个参数：
            <element directive="expression | filterId [args...]"></element>
    4.2 Examples 例子
        过滤器必须放在指令值的末尾：
            <span  v-text = "消息 | 大写" > </span>
        您还可以在 mustache 样式绑定中使用它们：
            <span>{{message | uppercase}}</span>
        多个过滤器可以链接在一起：
            <span>{{message | lowercase | reverse}}</span>

    4.3 Arguments 论据
        一些过滤器可以采用可选参数。只需添加由空格分隔的参数：
            <span>{{order | pluralize st nd rd th}}</span>
            <input v-on="keyup: submitForm | key enter">

5. Displaying a List 显示列表
    您可以使用该v-repeat指令根据 ViewModel 上的对象数组重复模板元素。对于 Array 中的每个对象，该指令将使用该对象作为其$data对象创建一个子 Vue 实例。
    这些子实例继承父实例的所有数据，因此在重复元素中，您可以访问重复实例和父实例的属性。此外，您还可以访问该$index属性，该属性将是渲染实例的相应 Array 索引。

    5.1 Example 例子
        <ul id="demo">
          <li v-repeat="items" class="item-{{$index}}">
            {{$index}} - {{parentMsg}} {{childMsg}}
          </li>
        </ul>
        var demo = new Vue({
          el: '#demo',
          data: {
            parentMsg: 'Hello',
            items: [
              { childMsg: 'Foo' },
              { childMsg: 'Bar' }
            ]
          }
        })

    5.2 Block Repeat 块重复
        有时您可能想要重复一个包含多个节点的块 - 在这种情况下，您可以使用<template>标签来包装重复块。此处的<template>标签仅用作语义包装器。例如：
            <ul>
              <template v-repeat="list">
                <li>{{msg}}</li>
                <li class="divider"></li>
              </template>
            </ul>

    5.2 Arrays of Primitive Values 原始值数组
        对于包含原始值的数组，您可以简单地访问该值$value：
            <ul id="tags">
              <li v-repeat="tags">
                {{$value}}
              </li>
            </ul>
            new Vue({
              el: '#tags',
              data: {
                tags: ['JavaScript', 'MVVM', 'Vue.js']
              }
            })

    5.3 Using an identifier 使用标识符
        有时我们可能想要更明确的变量访问，而不是隐式地回退到父范围。您可以通过向v-repeat指令提供一个参数并将其用作被迭代项的标识符来做到这一点：
            <ul id="users">
              <!-- think of this as "for each user in users" -->
              <li v-repeat="user: users">
                {{user.name}} - {{user.email}}
              </li>
            </ul>
            new Vue({
              el: '#users',
              data: {
                users: [
                  { name: 'Foo Bar', email: 'foo@bar.com' },
                  { name: 'John Doh', email: 'john@doh.com' }
                ]
              }
            })

    5.4 Mutation Methods 突变方法
        在后台，Vue.js 拦截了观察到的 Array 的变异方法（push()、pop()、shift()、unshift()、和） splice()，因此它们也会触发 View 更新。sort()reverse()
            // the DOM will be updated accordingly
            demo.items.unshift({ childMsg: 'Baz' })
            demo.items.pop()

    5.5 Augmented Methods 增强方法
        Vue.js 使用两种方便的方法来增强观察到的数组：$set()和$remove().

        您应该避免使用索引直接设置数据绑定数组的元素，因为 Vue.js 不会获取这些更改。相反，使用增强的$set()方法：
            // 与 `demo.items[0] = ...` 相同，但会触发视图更新
            demo.items.$set( 0 , { childMsg: 'Changed!' })

        $remove()只是splice(). 它将删除给定索引处的元素。当参数不是数字时，$remove()将在数组中搜索该值并删除第一个出现的值。

            // 删除索引 0 处的项目
            demo.items.$remove( 0 )

    5.6 Replacing an Array 替换阵列
        当您使用非变异方法时，例如或filter()，返回的 Array 将是一个不同的实例。在这种情况下，您可以用新的 Array 替换旧的 Array：concat()slice()
            demo.items = demo.items.filter(function (item) {
              return item.childMsg.match(/Hello/)
            })
        你可能会认为这会摧毁现有的 DOM 并重新构建一切。但不要担心——Vue.js 会识别已经有关联的 Vue 实例的数组元素，并会尽可能重用这些实例。

    5.7 Using track-by 使用 track-by
        在某些情况下，您可能需要用全新的对象替换 Array - 例如从 API 调用返回的对象。如果您的数据对象具有唯一的 id 属性，那么您可以使用track-by属性给 Vue.js 一个提示，
        以便它可以重用具有相同 id 数据的现有实例。

        例如，如果您的数据如下所示：
            {
              items: [
                { _uid: '88f869d', ... },
                { _uid: '7496c10', ... }
              ]
            }
        然后你可以给出这样的提示：
            <div v-repeat="items" track-by="_uid">
              <!-- content -->
            </div>

    5.8 Iterating Through An Object     遍历一个对象
        您还可以使用v-repeat来遍历对象的属性。每个重复的实例都有一个特殊的属性$key。对于原始值，您还可以获得$value类似于数组中的原始值。
            <ul id="repeat-object">
              <li v-repeat="primitiveValues">{{$key}} : {{$value}}</li>
              <li>===</li>
              <li v-repeat="objectValues">{{$key}} : {{msg}}</li>
            </ul>

            new Vue({
              el: '#repeat-object',
              data: {
                primitiveValues: {
                  FirstName: 'John',
                  LastName: 'Doe',
                  Age: 30
                },
                objectValues: {
                  one: {
                    msg: 'Hello'
                  },
                  two: {
                    msg: 'Bye'
                  }
                }
              }
            })
        在 ECMAScript 5 中，无法检测何时将新属性添加到对象，或何时从对象中删除属性。为了解决这个问题，观察到的对象将增加三种方法$add(key, value)：$set(key, value)和$delete(key)。
        这些方法可用于在触发所需的视图更新时从观察到的对象中添加/删除属性。$add和之间的区别在于，如果对象上已经存在键，它将提前返回，因此仅调用$set不会用 覆盖现有值。$addobj.$add(key)undefined

    5.9 Iterating Over a Range 在一个范围内迭代
        v-repeat也可以取整数。在这种情况下，它将多次重复模板。
            <div id="range">
                <div v-repeat="val">Hi! {{$index}}</div>
            </div>

            new Vue({
              el: '#range',
              data: {
                val: 3
              }
            });

    5.10 Array Filters 阵列过滤器
        有时我们只需要显示 Array 的过滤或排序版本，而无需实际改变或重置原始数据。Vue 提供了两个内置过滤器来简化这种用法：filterBy和orderBy. 查看他们的文档以获取更多详细信息。

6. 监听事件
    您可以使用该v-on指令将事件侦听器绑定到 DOM 事件。它可以绑定到事件处理函数（没有调用括号）或内联表达式。如果提供了处理函数，
    它将获取原始 DOM 事件作为参数。该事件还带有一个额外的属性：targetVM，指向触发事件的特定 ViewModel：
        <div id="demo">
          <a v-on="click: onClick">Trigger a handler</a>
          <a v-on="click: n++">Trigger an expression</a>
        </div>

        new Vue({
          el: '#demo',
          data: {
            n: 0
          },
          methods: {
            onClick: function (e) {
              console.log(e.target.tagName) // "A"
              console.log(e.targetVM === this) // true
            }
          }
        })

    6.1 Invoke Handler with Expression 使用表达式调用处理程序
        targetVM与一起使用时可能很有v-on用v-repeat，因为后者会创建很多子 ViewModel。但是，使用传入的调用表达式通常更方便this，它等于当前上下文 ViewModel：
            <ul id="list">
              <li v-repeat="items" v-on="click: toggle(this)">{{text}}</li>
            </ul>

            new Vue({
              el: '#list',
              data: {
                items: [
                  { text: 'one', done: true },
                  { text: 'two', done: false }
                ]
              },
              methods: {
                toggle: function (item) {
                  item.done = !item.done
                }
              }
            })
        当您想在表达式处理程序中访问原始 DOM 事件时，可以将其传递为$event：
            <button v-on="click: submit('hello!', $event)">Submit</button>
            {
              methods: {
                submit: function (msg, e) {
                  e.stopPropagation()
                }
              }
            }

    6.2 The Special key Filter 特殊key过滤器
        在监听键盘事件时，我们经常需要检查常用键码。Vue.js 提供了一个key只能与v-on指令一起使用的特殊过滤器。它需要一个参数来表示要检查的关键代码：
            <!-- 仅在 keyCode 为 13 时调用 vm.submit() -->
            <input v-on="keyup:submit | key 13">
        它还有一些常用键的预设：
            <!-- 同上 -->
            <input v-on="keyup:submit | key enter">

    6.3 Why Listeners in HTML? 为什么使用 HTML 中的侦听器
        您可能会担心整个事件监听方法违反了关于“关注点分离”的良好旧规则。请放心 - 由于所有 Vue.js 处理函数和表达式都严格绑定到处理当前视图的 ViewModel，因此不会造成任何维护困难。事实上，使用 有几个好处v-on：

            只需浏览 HTML 模板，就可以更轻松地在 JS 代码中找到处理程序函数的实现。
            由于您不必在 JS 中手动附加事件侦听器，因此您的 ViewModel 代码可以是纯逻辑和无 DOM 的。这使得测试更容易。
            当一个 ViewModel 被销毁时，所有的事件监听器都会被自动移除。你不必担心自己清理它。

7. Handling Forms 处理表单
    7.1 The Basics 基础知识
        您可以使用该v-model指令在表单输入元素上创建双向数据绑定。它会根据输入类型自动选择正确的方式来更新元素。

        例子
            <form id="demo">
              <!-- text -->
              <p>
                <input type="text" v-model="msg">
                {{msg}}
              </p>
              <!-- checkbox -->
              <p>
                <input type="checkbox" v-model="checked">
                {{checked ? "yes" : "no"}}
              </p>
              <!-- radio buttons -->
              <p>
                <input type="radio" name="picked" value="one" v-model="picked">
                <input type="radio" name="picked" value="two" v-model="picked">
                {{picked}}
              </p>
              <!-- select -->
              <p>
                <select v-model="selected">
                  <option>one</option>
                  <option>two</option>
                </select>
                {{selected}}
              </p>
              <!-- multiple select -->
              <p>
                <select v-model="multiSelect" multiple>
                  <option>one</option>
                  <option>two</option>
                  <option>three</option>
                </select>
                {{multiSelect}}
              </p>
              <p><pre>data: {{$data | json 2}}</pre></p>
            </form>

            new Vue({
              el: '#demo',
              data: {
                msg      : 'hi!',
                checked  : true,
                picked   : 'one',
                selected : 'two',
                multiSelect: ['one', 'three']
              }
            })

    7.2 Lazy Updates 延迟更新
        默认情况下，在每个事件v-model之后将输入与数据同步。input您可以添加一个lazy属性来更改change事件后同步的行为：
            <!-- synced after "change" instead of "input" -->
            <input v-model="msg" lazy>


    7.3 Casting Value as Number  将值转换为数字
        如果您希望用户输入自动保存为数字，您可以向托管输入添加一个number属性：v-model
            <input v-model="age" number>

    7.4 Dynamic Select Options 动态选择选项
        当您需要动态呈现<select>元素的选项列表时，建议将options属性与v-model：
            <select v-model="selected" options="myOptions"></select>

        在您的数据中，myOptions应该是指向要用作其选项的数组的键路径/表达式。Array 可以包含纯字符串，也可以包含对象。

        对象的格式可以是{text:'', value:''}. 这允许您将选项文本显示为与其基础值不同：
            [
              { text: 'A', value: 'a' },
              { text: 'B', value: 'b' }
            ]
        将渲染：
            <select>
              <option value="a">A</option>
              <option value="b">B</option>
            </select>

        或者，对象可以是{ label:'', options:[...] }. 在这种情况下，它将呈现为<optgroup>：
            [
              { label: 'A', options: ['a', 'b']},
              { label: 'B', options: ['c', 'd']}
            ]

        将渲染：
            <select>
              <optgroup label="A">
                <option value="a">a</option>
                <option value="b">b</option>
              </optgroup>
              <optgroup label="B">
                <option value="c">c</option>
                <option value="d">d</option>
              </optgroup>
            </select>


    7.5 Input Debounce  输入去抖动
        该debounce参数允许您在每次击键后在执行更新之前设置最小延迟。当您在每次更新上执行昂贵的操作时，这可能很有用，例如为预先输入自动完成发出 Ajax 请求。
            <input v-model="msg" debounce="500">

8. Computed Properties 计算属性
    Vue.js 的内联表达式非常方便，但它们的最佳用例是简单的布尔运算或字符串连接。对于更复杂的逻辑，您应该使用计算属性。

    在 Vue.js 中，您可以使用以下computed选项定义计算属性：

        var demo = new Vue({
          data: {
            firstName: 'Foo',
            lastName: 'Bar'
          },
          computed: {
            fullName: {
              // the getter should return the desired value
              get: function () {
                return this.firstName + ' ' + this.lastName
              },
              // the setter is optional
              set: function (newValue) {
                var names = newValue.split(' ')
                this.firstName = names[0]
                this.lastName = names[names.length - 1]
              }
            }
          }
        })

        demo.fullName // 'Foo Bar'

    当您只需要 getter 时，您可以提供单个函数而不是对象：
        // ...
        computed: {
          fullName: function () {
            return this.firstName + ' ' + this.lastName
          }
        }
        // .

    计算属性本质上是使用 getter/setter 函数定义的属性。您可以像使用普通属性一样使用计算属性，但是当您访问它时，您会得到 getter 函数返回的值；当你改变它的值时，你会触发 setter 函数传入新值作为它的参数。

    在 Vue.js 0.11 之前，曾经有一个依赖集合陷阱，它要求用户在涉及条件语句时显式列出依赖关系。从 0.11 开始，不再需要这样做。

9. Custom Directives 自定义指令
    9.1 The Basics 基础知识
        Vue.js 允许您注册自定义指令，本质上使您能够教授 Vue 新技巧，了解如何将数据更改映射到 DOM 行为。您可以使用该方法注册全局自定义指令Vue.directive(id, definition)，传入指令 id后跟定义对象。一个定义对象可以提供几个钩子函数（都是可选的）：

            bind：仅在指令第一次绑定到元素时调用一次。
            update：在初始值之后立即调用bind，然后在绑定值更改时再次调用。新值和先前值作为参数提供。
            unbind：仅在指令与元素解除绑定时调用一次。
        例子
            Vue.directive('my-directive', {
              bind: function () {
                // do preparation work
                // e.g. add event listeners or expensive stuff
                // that needs to be run only once
              },
              update: function (newValue, oldValue) {
                // do something based on the updated value
                // this will also be called for the initial value
              },
              unbind: function () {
                // do clean up work
                // e.g. remove event listeners added in bind()
              }
            })

        Once registered, you can use it in Vue.js templates like this (you need to add the Vue.js prefix to it):
        注册后，您可以像这样在 Vue.js 模板中使用它（您需要为其添加 Vue.js 前缀）：

            <div v-my-directive="someValue"></div>

        When you only need the update function, you can pass in a single function instead of the definition object:
        当你只需要update函数时，你可以传入单个函数而不是定义对象：
            Vue.directive('my-directive', function (value) {
              // this function will be used as update()
            })

        所有钩子函数都将被复制到实际的指令对象中，您可以在这些函数中作为它们的this上下文访问它。指令对象公开了一些有用的属性：

            el：指令绑定的元素。
            vm：拥有该指令的上下文 ViewModel。
            expression：绑定的表达式，不包括参数和过滤器。
            arg : 参数，如果存在的话。
            raw：原始的、未解析的表达式。
            name：指令的名称，不带前缀。
        您应该将所有这些属性视为只读，并避免更改它们。您也可以将自定义属性附加到指令对象，但请注意不要意外覆盖现有的内部属性。

        使用其中一些属性的自定义指令示例：
            <div id="demo" v-demo="LightSlateGray : msg"></div>
            Vue.directive('demo', {
              bind: function () {
                this.el.style.color = '#fff'
                this.el.style.backgroundColor = this.arg
              },
              update: function (value) {
                this.el.innerHTML =
                  'name - '       + this.name + '<br>' +
                  'raw - '        + this.raw + '<br>' +
                  'expression - ' + this.expression + '<br>' +
                  'argument - '   + this.arg + '<br>' +
                  'value - '      + value
              }
            })
            var demo = new Vue({
              el: '#demo',
              data: {
                msg: 'hello!'
              }
            })

    9.2 Literal Directives 文字指令
        如果您在isLiteral: true创建自定义指令时传入，则属性值将被视为文字字符串并分配为该指令的expression. 该指令不会尝试设置数据观察。

        例子：
            <div v-literal-dir="foo"></div>
            Vue.directive('literal-dir', {
              isLiteral: true,
              bind: function () {
                console.log(this.expression) // 'foo'
              }
            })

        9.2.1 Dynamic Literal 动态文字
            但是，如果文字指令包含 mustache 标签，则行为如下：

                指令实例将有一个标志this._isDynamicLiteral设置为true;

                如果未update提供任何函数，则 mustache 表达式将只计算一次并分配给this.expression. 没有数据观察发生。

                如果update提供了一个函数，该指令将为该表达式设置数据观察，并update在评估结果更改时调用。

    9.3 Two-way Directives 双向指令
        如果您的指令希望将数据写回 Vue 实例，则需要传入twoWay: true. 此选项允许在this.set(value)指令内部使用：
            Vue.directive('example', {
              twoWay: true,
              bind: function () {
                this.handler = function () {
                  // set data back to the vm.
                  // If the directive is bound as v-example="a.b.c",
                  // this will attempt to set `vm.a.b.c` with the
                  // given value.
                  this.set(this.el.value)
                }.bind(this)
                this.el.addEventListener('input', this.handler)
              },
              unbind: function () {
                this.el.removeEventListener('input', this.handler)
              }
            })
    9.4 Inline Statements 内联语句
        传入acceptStatement:true使您的自定义指令能够接受内联语句，例如v-on：
            <div v-my-directive="a++"></div>
            Vue.directive('my-directive', {
              acceptStatement: true,
              update: function (fn) {
                // the passed in value is a function which when called,
                // will execute the "a++" statement in the owner vm's
                // scope.
              }
            })
        但是请明智地使用它，因为通常您希望避免模板中的副作用。

    9.5 Deep Observation 深度观察
        如果您的自定义指令预计将用于对象，并且需要update在对象内的嵌套属性更改时触发，则需要传入deep: true指令定义。
            <div v-my-directive="obj"></div>
            Vue.directive('my-directive', {
              deep: true,
              update: function (obj) {
                // will be called when nested properties in `obj`
                // changes.
              }
            })
    9.6 Directive Priority 指令优先级
        您可以选择为指令提供优先级编号（默认为 0）。具有更高优先级的指令将比同一元素上的其他指令更早地处理。具有相同优先级的指令将按照它们在元素属性列表中出现的顺序进行处理，尽管该顺序不能保证在不同的浏览器中是一致的。

        您可以在API 参考中查看某些内置指令的优先级。此外，v-repeat和v-if被v-component认为是“终端指令”，它们在编译过程中始终具有最高优先级。

10. Custom Filters 自定义过滤器
    10.1 The Basics 基础知识
        与自定义指令类似，您可以使用全局Vue.filter()方法注册自定义过滤器，传入filterID和过滤器函数。过滤器函数将一个值作为参数并返回转换后的值：
            Vue.filter('reverse', function (value) {
              return value.split('').reverse().join('')
            })
            <!-- 'abc' => 'cba' -->
            <span v-text="message | reverse"></span>

        过滤器函数还接收任何内联参数：
            Vue.filter('wrap', function (value, begin, end) {
              return begin + value + end
            })
            <!-- 'hello' => 'before hello after' -->
            <span v-text="message | wrap before after"></span>

    10.2 Two-way Filters 双向过滤器
        到目前为止，我们已经使用过滤器来转换来自模型的值，然后再将它们显示在视图中。但也可以定义一个过滤器，在将值从视图（输入元素）写回模型之前对其进行转换
            Vue.filter('check-email', {
              // read is optional in this case, it's here
              // just for demo purposes.
              read: function (val) {
                return val
              },
              // this will be invoked before writing to
              // the model.
              write: function (val, oldVal) {
                return isEmail(val) ? val : oldVal
              }
            })

    10.3 Filter Context 过滤上下文
        当一个过滤器被调用时，它的this上下文被设置为调用它的 Vue 实例。这允许它根据所有者 Vue 实例的状态输出动态结果。

        例如：
            Vue.filter('concat', function (value, key) {
              // `this` points to the Vue instance invoking the filter
              return value + this[key]
            })

            <input v-model="userInput">
            <span>{{msg | concat userInput}}</span>



        对于上面这个简单的示例，您可以只使用一个表达式来获得相同的结果，但是对于需要多个语句的更复杂的过程，您需要将它们放在计算属性或自定义过滤器中。

        built-infilterBy和orderByfilters 都是对传入的 Array 执行重要工作的过滤器，并依赖于所有者 Vue 实例的当前状态。

11. Component System 组件系统
    11.1 使用组件
        Vue.js 允许您将扩展的 Vue 子类视为在概念上类似于Web Components的可重用组件，而无需任何 polyfill。要创建组件，只需使用以下命令创建 Vue 的子类构造函数Vue.extend()：
            // Extend Vue to get a reusable constructor
            var MyComponent = Vue.extend({
              template: 'A custom component!'
            })

        大多数可以传递给 Vue 构造函数的选项都可以在 中使用Vue.extend()，但是，有两种特殊情况，data和el. 由于每个 Vue 实例都应该有自己的$dataand $el，
        我们显然不希望我们传入的值Vue.extend()在从该构造函数创建的所有实例之间共享。所以当你想定义一个组件应该如何初始化它的默认数据或元素时，你应该传入一个函数：
            var ComponentWithDefaultData = Vue.extend({
              data: function () {
                return {
                  title: 'Hello!'
                }
              }
            })


        然后，您可以使用以下方式注册该构造函数Vue.component()：
            // Register the constructor with id: my-component
            Vue.component('my-component', MyComponent)

        为了使事情更容易，您还可以直接传入选项对象而不是实际的构造函数。如果它收到一个对象，Vue.component()将隐式调用你：Vue.extend()

            // Note: this method returns the global Vue,
            // not the registered constructor.
            Vue.component('my-component', {
              template: 'A custom component!'
            })

        然后您可以在父实例的模板中使用已注册的组件（确保在实例化根 Vue 实例之前已注册该组件）：
            <!-- inside parent template -->
            <div v-component="my-component"></div>

        如果您愿意，也可以以自定义元素标签的形式使用组件：
            <my-component></my-component>

        为了避免与原生元素的命名冲突并与 W3C 自定义元素规范保持一致，组件的 ID必须包含连字符-才能用作自定义标记。

        Vue.extend()了解和之间的区别很重要Vue.component()。由于Vue本身是构造函数，Vue.extend()是类继承方法。它的任务是创建一个子类Vue并返回构造函数。Vue.component()另一方面，是一种类似于和的资产登记方式。它的任务是将给定的构造函数与字符串 ID 相关联，以便 Vue.js 可以在模板中获取它。当直接将选项传递给 时，它会在后台调用。Vue.directive()Vue.filter()Vue.component()Vue.extend()

        Vue.js 支持两种不同的 API 范例：基于类的命令式 Backbone 样式 API 和基于标记的声明式 Web 组件样式 API。如果您感到困惑，请考虑如何使用new Image()或<img>标签创建图像元素。每个都有自己的用途，Vue.js 提供了最大的灵活性。

    11.2 Data Inheritance 数据继承
        11.2.1 Explicit Data Passing 显式数据传递
            默认情况下，组件具有隔离范围。这意味着您不能在子组件的模板中引用父数据。要显式地将数据传递给具有隔离范围的子组件，我们可以使用该v-with指令。

            Passing Down Child $data 传下来的孩子$data
                当给定一个不带参数的键路径时，父级上的相应值将作为其$data. 这意味着传递的值必须是一个对象，它将覆盖$data子组件可能具有的默认对象。

                例子：
                    <div id="demo-1">
                      <p v-component="user-profile" v-with="user"></p>
                    </div>
                    // registering the component first
                    Vue.component('user-profile', {
                      template: '{{name}}<br>{{email}}'
                    })
                    // the `user` object will be passed to the child
                    // component as its $data
                    var parent = new Vue({
                      el: '#demo-1',
                      data: {
                        user: {
                          name: 'Foo Bar',
                          email: 'foo@bar.com'
                        }
                      }
                    })
            Passing Down Individual Properties 传递个人财产
                v-with也可以与 形式的参数一起使用v-with="childProp: parentProp"。这意味着传递parent[parentProp]给子 as child[childProp]，创建双向绑定（从 0.11.5 开始）。
                    <div id="demo-2">
                      <input v-model="parentMsg">
                      <p v-component="child" v-with="childMsg : parentMsg">
                        <!-- essentially means "bind `parentMsg` on me as `childMsg`" -->
                      </p>
                    </div>
                    new Vue({
                      el: '#demo-2',
                      data: {
                        parentMsg: 'Inherited message'
                      },
                      components: {
                        child: {
                          template: '<span>{{childMsg}}</span>'
                        }
                      }
                    })


            Using paramAttributes 使用paramAttributes
                也可以使用paramAttributes编译为 的选项v-with来公开一个看起来更像自定义元素的界面：
                    <div id="demo-3">
                      <input v-model="parentMsg">
                      <child-component child-msg="{{parentMsg}}"></child-component>
                    </div>
                    new Vue({
                      el: '#demo-3',
                      data: {
                        parentMsg: 'Inherited message'
                      },
                      components: {
                        'child-component': {
                          paramAttributes: ['child-msg'],
                          // dashed attributes are camelized,
                          // so 'child-msg' becomes 'this.childMsg'
                          template: '<span>{{childMsg}}</span>'
                        }
                      }
                    })

        11.2.2 Scope Inheritance
            如果需要，您还可以使用inherit: true子组件的选项使其原型继承所有父属性：
                var parent = new Vue({
                  data: {
                    a: 1
                  }
                })
                // $addChild() is an instance method that allows you to
                // programatically create a child instance.
                var child = parent.$addChild({
                  inherit: true,
                  data: {
                    b: 2
                  }
                })
                console.log(child.a) // -> 1
                console.log(child.b) // -> 2
                parent.a = 3
                console.log(child.a) // -> 3

            请注意，这有一个警告：因为 Vue 实例上的数据属性是 getter/setter，所以设置child.a = 2会改变，parent.a而不是在子节点上创建一个新属性来影响父节点：
                child.a = 4
                console.log(parent.a) // -> 4
                console.log(child.hasOwnProperty('a')) // -> false

        11.2.3 A Note on Scope 在父模板中使用组件时，
            例如：
                <div v-component v-show="active" v-on="click:onClick"></div>
            此处的指令 ( v-showand v-on) 将在父级范围内编译，因此activeand的值onClick将针对父级解析。子模板内的任何指令/插值都将在子范围内编译。这确保了父组件和子组件之间的更清晰的分离。

            此规则也适用于内容插入，如本指南后面所述。

    11.3 Component Lifecycle 组件生命周期
        每个组件或 Vue 实例都有自己的生命周期：它将被创建、编译、附加或分离，最后被销毁。在每个关键时刻，实例都会发出相应的事件，在创建实例或定义组件时，我们可以传入生命周期钩子函数来对这些事件做出反应。例如：
            var MyComponent = Vue.extend({
              created: function () {
                console.log('An instance of MyComponent has been created!')
              }
            })

    11.4 Dynamic Components 动态组件
        可以通过指令内部的 Mustache 标签在组件之间动态切换v-component，可以和路由一起使用实现“页面切换”：
            new Vue({
              el: 'body',
              data: {
                currentView: 'home'
              },
              components: {
                home: { /* ... */ },
                posts: { /* ... */ },
                archive: { /* ... */ }
              }
            })

            <div v-component="{{currentView}}">
              <!-- content changes when vm.currentview changes! -->
            </div>

        如果您想保持切换出的组件处于活动状态，以便您可以保留其状态或避免重新渲染，您可以添加一个keep-alive指令参数：
            <div v-component="{{currentView}}" keep-alive>
              <!-- inactive components will be cached! -->
            </div>

        11.4.1 Transition Control 过渡控制
            有两个附加属性参数允许对动态组件应如何从一个过渡到另一个进行高级控制。

            wait-for
                在与当前组件切换之前等待传入子组件的事件名称。这允许您在触发转换之前等待异步数据加载，以避免在两者之间出现不必要的空虚。
                    <div v-component="{{view}}" wait-for="data-loaded"></div>
                    // component definition
                    {
                      // fetch data and fire the event asynchronously in the
                      // compiled hook. Using jQuery just for example.
                      compiled: function () {
                        var self = this
                        $.ajax({
                          // ...
                          success: function (data) {
                            self.$data = data
                            self.$emit('data-loaded')
                          }
                        })
                      }
                    }

            transition-mode
                默认情况下，传入和传出组件的转换同时发生。此参数允许您配置另外两种模式：

                    in-out: 新组件首先过渡，当前组件在传入过渡完成后过渡。
                    out-in：当前组件首先过渡出去，新组件过渡在外出过渡完成后过渡。
                <div v-component="{{view}}"
                  v-transition="fade"
                  transition-mode="out-in">
                </div>

    11.5 List and Components 列表和组件
        对于对象数组，您可以v-component与v-repeat. 在这种情况下，对于 Array 中的每个 Object，将使用该 Object 作为数据创建一个子 ViewModel，并将指定的组件作为构造函数。
            <ul id="demo-4">
              <!-- reusing the user-profile component we registered before -->
              <li v-repeat="users" v-component="user-profile"></li>
            </ul>
            var parent2 = new Vue({
              el: '#demo-4',
              data: {
                users: [
                  {
                    name: 'Chuck Norris',
                    email: 'chuck@norris.com'
                  },
                  {
                    name: 'Bruce Lee',
                    email: 'bruce@lee.com'
                  }
                ]
              }
            })

    11.6 Child Reference  子参考
        有时您可能需要访问 JavaScript 中的嵌套子组件。要启用它，您必须使用 为子组件分配参考 ID v-ref。例如：
            <div id="parent">
              <div v-component="user-profile" v-ref="profile"></div>
            </div>
            <div id="parent">
              <div v-component="user-profile" v-ref="profile"></div>
            </div>

        v-ref与 一起使用时，v-repeat您得到的值将是一个包含镜像数据数组的子组件的数组。

    11.7 Event System 事件系统
        虽然可以直接访问一个 ViewModels 的 children 和 parent，但是使用内置的事件系统进行跨组件通信会更方便。它还使您的代码耦合更少并且更易于维护。一旦建立了父子关系，您就可以使用每个 ViewModel 的事件实例方法来调度和触发事件。
            var Child = Vue.extend({
              created: function () {
                this.$dispatch('child-created', this)
              }
            })

            var parent = new Vue({
              template: '<div v-component="child"></div>',
              components: {
                child: Child
              },
              created: function () {
                this.$on('child-created', function (child) {
                  console.log('new child created: ')
                  console.log(child)
                })
              }
            })
    11.8 Private Assets 私人资产
        有时组件需要使用诸如指令、过滤器和它自己的子组件之类的资产，但可能希望将这些资产封装起来，以便组件本身可以在其他地方重用。您可以使用私有资产实例化选项来做到这一点。私有资产只能由所有者组件及其子组件的实例访问。
            // All 5 types of assets
            var MyComponent = Vue.extend({
              directives: {
                // id : definition pairs same with the global methods
                'private-directive': function () {
                  // ...
                }
              },
              filters: {
                // ...
              },
              components: {
                // ...
              },
              partials: {
                // ...
              },
              effects: {
                // ...
              }
            })
        或者，您可以使用类似于全局资产注册方法的链接 API 将私有资产添加到现有组件构造函数：
            MyComponent
              .directive('...', {})
              .filter('...', function () {})
              .component('...', {})
              // ...

    11.9 Content Insertion 内容插入
        在创建可重用组件时，我们经常需要访问和重用宿主元素中的原始内容，这些内容不属于组件的一部分（类似于 Angular 的“transclusion”概念）。Vue.js 实现了兼容的内容插入机制使用当前的 Web Components 规范草案，使用特殊<content>元素作为原始内容的插入点。

        重要提示：被嵌入的内容是在父组件的范围内编译的，而不是在子组件的范围内。
        11.9.1 Single Insertion Point 单插入点
            当只有一个<content>标签没有属性时，整个原始内容将被插入到它在 DOM 中的位置并替换它。最初在<content>标签内的任何内容都被视为后备内容。仅当托管元素为空且没有要插入的内容时，才会显示后备内容。例如：

            模板my-component：
                <h1>This is my component!</h1>
                <content>This will only be displayed if no content is inserted</content>


            使用组件的父标记：
                <div v-component="my-component">
                  <p>This is some original content</p>
                  <p>This is some more original content</p>
                </div>

            渲染的结果将是：
                <div>
                  <h1>This is my component!</h1>
                  <p>This is some original content</p>
                  <p>This is some more original content</p>
                </div>

        11.9.2 Multiple Insertion Points 多个插入点
            <content>元素有一个特殊的属性，select，它需要一个 CSS 选择器。您可以有多个<content>具有不同select属性的插入点，每个插入点都将被原始内容中与该选择器匹配的元素替换。

            从 0.11.6 开始，<content>选择器只能匹配主机节点的顶级子节点。这使行为与 Shadow DOM 规范保持一致，并避免在嵌套嵌入中意外选择不需要的节点。

            模板multi-insertion-component：
                <content select="p:nth-child(3)"></content>
                <content select="p:nth-child(2)"></content>
                <content select="p:nth-child(1)"></content>

            父标记：
                <div v-component="multi-insertion-component">
                  <p>One</p>
                  <p>Two</p>
                  <p>Three</p>
                </div>


            渲染的结果将是：
                <div>
                  <p>Three</p>
                  <p>Two</p>
                  <p>One</p>
                </div>

            内容插入机制提供了对如何操作或显示原始内容的精细控制，使组件非常灵活和可组合。

    11.10 Inline Template 内联模板
          在 0.11.6 中，v-component引入了一个新的指令参数：inline-template. 当此参数存在时，组件将使用其内部内容作为其模板，而不是嵌入内容。这允许更灵活的模板创作。
            <div v-component="example" inline-template>
              <p>These are compiled as the component's own template</p>
              <p>Not parent's transclusion content.</p>
            </div>

12. Transitions 过渡
    使用 Vue.js 的过渡系统，您可以在将元素插入 DOM 或从 DOM 中删除时应用自动过渡效果。有两种选择：使用过渡/动画定义 CSS 类，或者通过注册包含自定义 JavaScript 钩子函数的定义对象。

    应用指令v-transition="my-transition"后，Vue 将：

        尝试查找通过选项注册或使用 idVue.transition(id, def)传入的 JavaScript 转换定义。如果找到它，它将使用该定义对象来执行基于 JavaScript 的自定义转换。transitions"my-transition"

        如果没有找到自定义的 JavaScript 过渡，它将自动嗅探目标元素是否应用了 CSS 过渡或 CSS 动画，并在适当的时间添加/删除 CSS 类。

        如果没有检测到过渡/动画，则在下一帧执行 DOM 操作。

    仅当 Vue.js 通过内置指令（例如v-if）或通过 Vue 实例方法（例如）应用 DOM 操作时，才会触发所有 Vue.js 转换vm.$appendTo()。

    12.1 CSS Transitions CSS 过渡
        典型的 CSS 过渡如下所示：
            <p class="msg" v-if="show" v-transition="expand">Hello!</p>
        您还需要为.expand-enter和.expand-leave类定义 CSS 规则：
            .msg {
              transition: all .3s ease;
              height: 30px;
              padding: 10px;
              background-color: #eee;
              overflow: hidden;
            }
            .msg.expand-enter, .msg.expand-leave {
              height: 0;
              padding: 0 10px;
              opacity: 0;
            }
        切换的类基于v-transition指令的值。在 的情况下v-transition="fade"，被切换的类将是.fade-enter和.fade-leave。当没有提供值时，它们将默认为.v-enterand .v-leave。

        当show属性发生变化时，Vue.js 将<p>相应地插入或删除元素，并应用如下指定的转换类：

        当show变为 false 时，Vue.js 将：

            将v-leave类应用于元素以触发过渡；
            等待过渡完成；（听一个transitionend事件）
            从 DOM 中移除元素并移除v-leave类。
        当show变为 true 时，Vue.js 将：

            将v-enter类应用于元素；
            将其插入 DOM；
            强制 CSS 布局以便v-enter实际应用；
            删除v-enter该类以触发转换回元素的原始状态。
        当多个元素一起转换时，Vue.js 将它们批处理并仅应用一种强制布局。


    12.2 CSS Animations CSS 动画
        CSS 动画以与 CSS 过渡相同的方式应用，不同之处在于v-enter元素插入后不会立即删除，而是在animationend回调时删除。

        示例：（此处省略前缀 CSS 规则）
            <p class="animated" v-if="show" v-transition="bounce">Look at me!</p>
            .animated {
              display: inline-block;
            }
            .animated.bounce-enter {
              animation: bounce-in .5s;
            }
            .animated.bounce-leave {
              animation: bounce-out .5s;
            }
            @keyframes bounce-in {
              0% {
                transform: scale(0);
              }
              50% {
                transform: scale(1.5);
              }
              100% {
                transform: scale(1);
              }
            }
            @keyframes bounce-out {
              0% {
                transform: scale(1);
              }
              50% {
                transform: scale(1.5);
              }
              100% {
                transform: scale(0);
              }
            }
    12.3  JavaScript Functions JavaScript 函数
        以下示例使用 jQuery 注册自定义 JavaScript 转换定义：
            Vue.transition('fade', {
              beforeEnter: function (el) {
                // a synchronous function called right before the
                // element is inserted into the document.
                // you can do some pre-styling here to avoid
                // FOC (flash of content).
              },
              enter: function (el, done) {
                // element is already inserted into the DOM
                // call done when animation finishes.
                $(el)
                  .css('opacity', 0)
                  .animate({ opacity: 1 }, 1000, done)
                // optionally return a "cancel" function
                // to clean up if the animation is cancelled
                return function () {
                  $(el).stop()
                }
              },
              leave: function (el, done) {
                // same as enter
                $(el).animate({ opacity: 0 }, 1000, done)
                return function () {
                  $(el).stop()
                }
              }
            })



        调用上述所有钩子函数时，它们的this上下文设置为关联的 Vue 实例。如果元素是 Vue 实例的根节点，则该实例将用作上下文。否则，上下文将是转换指令的所有者实例。

        然后，您可以通过提供转换 id 来使用它v-transition。请注意，这比 CSS 过渡具有更高的优先级。
            <p v-transition="fade"></p>
13. Building Larger Apps  构建更大的应用程序
    Vue.js 被设计为尽可能灵活——它只是一个不强制执行任何架构决策的接口库。虽然这对于快速原型设计非常有用，但对于那些经验较少的人来说，用它构建更大规模的应用程序可能是一个挑战。以下是关于在使用 Vue.js 时如何组织大型项目的观点。

    13.1 Modularization 模块化
        尽管 Vue.js 的独立构建可以用作全局构建，但通常最好利用模块化构建系统来更好地组织代码。这样做的推荐方法是在 CommonJS 模块中编写源代码（Node.js 使用的格式，以及 Vue.js 源代码使用的格式）并使用Browserify或Webpack捆绑它们。

        以下是 GitHub 上的一些构建设置示例：

            Vue + 浏览器
            Vue + Webpack

    13.2 Single File Components 单个文件组件
         在一个典型的 Vue.js 项目中，我们会将我们的代码分解成许多小组件，最好让每个组件在同一个地方封装其 CSS 样式、模板和 JavaScript 定义。使用前面提到的构建工具的一个好处是，它们都提供了在将源代码捆绑在一起之前转换源代码的机制，并且通过一些预处理，我们可以像这样编写我们的组件：
         这是通过使用 Browserify 的Vueify转换或 Webpack 的Vue-loader来实现的。

    13.3 Routing 路由
         您可以通过手动监听 hashchange 并利用动态v-component.

         例子：
            <div id="app">
              <div v-component="{{currentView}}"></div>
            </div
            Vue.component('home', { /* ... */ })
            Vue.component('page1', { /* ... */ })
            var app = new Vue({
              el: '#app',
              data: {
                currentView: 'home'
              }
            })
            // Switching pages in your route handler:
            app.currentView = 'page1'
         通过这种机制，可以很容易地利用独立的路由库，例如Page.js或Director。
    13.4 Communication with Server 与服务器通信
         $data所有 Vue 实例都可以直接序列化它们的原始数据，JSON.stringify()而无需额外的努力。您可以使用任何您喜欢的 Ajax 组件，例如SuperAgent。它还可以很好地与 Firebase 等无后端服务配合使用。

    13.5 Unit Testing 单元测试
         任何与基于 CommonJS 的构建系统兼容的东西都可以工作。一个建议是使用Karma测试运行器和它的CommonJS 预处理器来模块化地测试你的代码。

         最佳实践是在模块内导出原始选项/函数。考虑这个例子：
            // my-component.js
            module.exports = {
              template: '<span>{{msg}}</span>',
              data: function () {
                return {
                  msg: 'hello!'
                }
              }
              created: function () {
                console.log('my-component created!')
              }
            }
         You can use that file in your entry module like this:
         您可以像这样在您的入口模块中使用该文件：
            // main.js
            var Vue = require('vue')
            var app = new Vue({
              el: '#app',
              data: { /* ... */ },
              components: {
                'my-component': require('./my-component')
              }
            })

         And you can test that module like this:
         您可以像这样测试该模块：

            // Some Jasmine 2.0 tests
            describe('my-component', function () {
              // require source module
              var myComponent = require('../src/my-component')
              it('should have a created hook', function () {
                expect(typeof myComponent.created).toBe('function')
              })
              it('should set correct default data', function () {
                expect(typeof myComponent.data).toBe('function')
                var defaultData = myComponent.data()
                expect(defaultData.message).toBe('hello!')
              })
            })

         由于 Vue.js 指令异步响应数据更新，当您在更改数据后断言 DOM 状态时，您必须在Vue.nextTick回调中这样做。或者，您可以Vue.config.async = false在测试期间进行设置，这样您就可以在数据更改后立即同步断言 DOM 状态。

    13.6 一个例子
         Vue.js Hackernews Clone是一个示例应用程序，它使用 Webpack + vue-loader 进行代码组织，Director.js 进行路由，
         并使用 HackerNews 的官方 Firebase API 作为后端。这绝不是一个大应用程序，但它展示了本页讨论的概念的组合用法。

14. Extending Vue 扩展 Vue
    14.1 Extend with Mixins 使用 Mixins 扩展
        Mixin 是一种为 Vue 组件分发可重用功能的灵活方式。你可以像普通的 Vue 组件选项对象一样编写 mixin：
            // mixin.js
            module.exports = {
              created: function () {
                this.hello()
              },
              methods: {
                hello: function () {
                  console.log('hello from mixin!')
                }
              }
            }
            // test.js
            var myMixin = require('./mixin')
            var Component = Vue.extend({
              mixins: [myMixin]
            })
            var component = new Component() // -> "hello from mixin!"

    14.2 Extend with Plugins 使用插件扩展
        插件通常会为 Vue 添加全局级别的功能。
        14.2.1 Writing a Plugin 编写插件
            您通常可以编写几种类型的插件：

                添加一个或多个全局方法。例如vue 元素
                添加一个或多个全局资产：指令/过滤器/转换等，例如vue-touch
                通过将它们附加到 Vue.prototype 来添加一些 Vue 实例方法。这里的约定是 Vue 实例方法应该以 为前缀$，这样它们就不会与用户数据和方法冲突。

                exports.install = function (Vue, options) {
                  Vue.myGlobalMethod = ...          // 1
                  Vue.directive('my-directive', {}) // 2
                  Vue.prototype.$myMethod = ...     // 3
                }

        14.2.2 Using a Plugin 使用插件
            假设使用 CommonJS 构建系统：
                var vueTouch = require('vue-touch')
                // use the plugin globally
                Vue.use(vueTouch)
            您还可以将其他选项传递给插件：
                Vue.use('my-plugin', {
                  /* pass in additional options */
                })

    14.3 Existing Tools 现有工具
        vue-devtools：用于调试 Vue.js 应用程序的 Chrome devtools 扩展。
        vue-touch：使用 Hammer.js 添加触摸手势指令。
        vue-element：使用 Vue.js 注册自定义元素。
        用户贡献工具列表 : https://github.com/yyx990803/vue/wiki/User-Contributed-Components-&-Tools


15. 常见问题解答
    为什么 Vue.js 不支持 IE8？

    Vue.js 能够提供纯 JavaScript 对象语法，而无需通过 using 进行脏检查Object.defineProperty，这是 ECMAScript 5 的一个特性。它仅适用于 IE8 中的 DOM 元素，并且无法为 JavaScript 对象填充它。

    所以 Vue.js 修改了我的数据？

    是和否。Vue.js 仅将普通属性转换为 getter 和 setter，以便在访问或更改属性时收到通知。序列化后，您的数据看起来完全一样。当然，有一些警告：

    当您console.log观察对象时，您只会看到一堆 getter/setter。但是，您可以使用它vm.$log()来记录更易于检查的输出。

    您不能在数据对象上定义自己的 getter/setter。这不是什么大问题，因为数据对象应该是从纯 JSON 中获取的，而 Vue.js 提供了计算属性。

    Vue.js 为被观察对象添加了一些额外的属性/方法：__ob__、$add和. 这些属性数不胜数，因此它们不会出现在循环中。但是，如果您覆盖它们，事情可能会中断。$set$deletefor ... in ...

    差不多就是这样。访问对象的属性和以前一样，JSON.stringify循环for ... in ...将正常工作。99.9% 的时间你甚至不需要考虑它。

    Vue.js 的现状如何？我可以在生产中使用它吗？

    Vue.js 已经为 0.11 更新进行了一些重大的重写，我们现在正朝着 1.0 版本努力。Vue.js 已经在 Optimizely 等公司的生产环境中使用。

    Vue.js 可以免费使用吗？

    Vue.js 在 MIT 许可下是免费且完全开源的。

    Vue.js 和 AngularJS 有什么区别？

    使用 Vue 而不是 Angular 有几个原因，尽管它们可能并不适用于所有人：

    Vue.js 是一种更灵活、更少固执己见的解决方案。这使您可以按照自己想要的方式构建应用程序，而不是被迫以 Angular 的方式做所有事情。它只是一个界面层，因此您可以将其用作页面中的轻量级功能，而不是完整的 SPA。它为您提供了更大的空间来与其他库进行混合和匹配。这可能是最重要的区别。

    Vue.js 通常比 Angular 简单得多，因此您可以非常快速地了解它的几乎所有内容并提高工作效率。

    Vue.js 具有更好的性能，因为它不使用脏检查。当有很多观察者时，Angular 会变慢，因为每当范围内的任何东西发生变化时，都需要重新评估所有这些观察者。Vue.js 不会受此影响，因为它使用基于事件的观察机制，因此所有更改都会独立触发，除非它们具有明确的依赖关系。

    Vue.js 在指令和组件之间有更清晰的分离。指令仅用于封装 DOM 操作，而组件代表具有自己的视图和数据逻辑的自包含单元。在 Angular 中，两者之间存在很多混淆。

    但也要注意，Vue.js 是一个相对年轻的项目，而 Angular 是久经考验的、由 Google 赞助的，并且拥有更大的社区。

    是什么让 Vue.js 与 KnockoutJS 不同？

    首先，Vue 在获取和设置 VM 属性时提供了更简洁的语法。

    在更高的层面上，Vue 与 Knockout 的不同之处在于 Vue 的组件系统鼓励您采用自上而下、结构优先、声明式的设计策略，而不是强制自下而上地构建 ViewModel。在 Vue 中，源数据是简单的、无逻辑的对象（您可以直接 JSON.stringify 并放入 post 请求中的对象），而 ViewModel 只是代理对自身数据的访问。Vue VM 实例总是将原始数据连接到相应的 DOM 元素。在 Knockout 中，ViewModel 本质上就是数据，Model 和 ViewModel 之间的界限非常模糊。这种差异化的缺乏使 Knockout 更加灵活，但也更有可能导致复杂的 ViewModel。

    是什么让 Vue.js 与 React.js 不同？

    React.js 和 Vue.js 确实有一些相似之处，因为它们都提供了响应式和可组合的 View 组件。然而，内部实现是根本不同的。React 是建立在一个虚拟 DOM 之上的——一个实际 DOM 应该是什么样子的内存表示。React 中的数据在很大程度上是不可变的，并且 DOM 操作是通过差异计算的。相反，Vue.js 中的数据默认是可变的和有状态的，变化是通过事件触发的。Vue.js 没有使用虚拟 DOM，而是使用实际 DOM 作为模板，并保留对实际节点的引用以进行数据绑定。

    虚拟 DOM 方法提供了一种在任何时间点描述视图的功能性方式，这非常好。因为它不使用 observables 并在每次更新时重新渲染整个应用程序，所以视图根据定义保证与数据同步。它还为同构 JavaScript 应用程序开辟了可能性。

    总的来说，我自己是 React 设计理念的忠实粉丝。但是 React 的一个问题是你的逻辑和你的观点是紧密结合在一起的。对于一些开发人员来说，这是一个奖励，但对于像我这样的设计师/开发人员混合体来说，拥有一个模板可以更容易地从视觉上思考设计和 CSS。JSX 与 JavaScript 逻辑的混合打破了我需要将代码映射到设计的可视化模型。相比之下，Vue.js 支付了轻量级 DSL（指令）的成本，因此我们有一个可视化的可扫描模板，并将逻辑封装到指令和过滤器中。

    React 的另一个问题是，因为 DOM 更新完全委托给虚拟 DOM，所以当你真正想自己控制 DOM时有点棘手（虽然理论上你可以，但当你这样做时，你实际上是在使用库） . 对于需要复杂的时间编排动画的应用程序，这可能成为一个非常烦人的限制。在这方面，Vue.js 允许更大的灵活性，并且有多个使用 Vue.js 构建的FWA/Awwwards 获奖网站。
